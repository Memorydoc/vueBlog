(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{358:function(t,v,_){"use strict";_.r(v);var i=_(10),a=Object(i.a)({},function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"mysql-事务与锁机制"}},[t._v("Mysql 事务与锁机制")]),t._v(" "),_("h2",{attrs:{id:"下面的脏读、不可重复读、幻读都是-模拟在a、b事务中进行的"}},[t._v("下面的脏读、不可重复读、幻读都是 模拟在A、B事务中进行的")]),t._v(" "),_("h2",{attrs:{id:"脏读"}},[t._v("脏读")]),t._v(" "),_("p",[t._v("A 事务 读取某一值的数据， B事务将该值修改了， A中会读取到")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/mysql/image-20200813210713283.png",alt:"image-20200813210713283"}})]),t._v(" "),_("h2",{attrs:{id:"不可重复读"}},[t._v("不可重复读")]),t._v(" "),_("p",[t._v("A 事务中 读取某一值的数据，B事务中将该值修改了， 并且 执行了commit ， 那么A中会读取到 (针对于 update  和  delete 语句)")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/mysql/image-20200813210704429.png",alt:"image-20200813210704429"}})]),t._v(" "),_("h2",{attrs:{id:"幻读"}},[t._v("幻读")]),t._v(" "),_("p",[t._v("A事务中 查询某一条件中的所有数据，第一次查询出来 2条， B事务中在该命中条件下， 又插入了一条数据，那么A再次查询， 会查出来")]),t._v(" "),_("p",[t._v("3条数据，出现幻读（针对于insert语句）")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/mysql/image-20200813210649975.png",alt:"image-20200813210649975"}})]),t._v(" "),_("h2",{attrs:{id:"事务隔离级别总结"}},[t._v("事务隔离级别总结")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/mysql/image-20200813210738819.png",alt:"image-20200813210738819"}})]),t._v(" "),_("blockquote",[_("p",[t._v("mysql 默认的事务隔离界别是 Repeatable Read 可重复读， 可以解决 上面 三大问题（InnoDB中可以解决）")])]),t._v(" "),_("h2",{attrs:{id:"mysql-innodb-事务隔离级别的支持程度"}},[t._v("Mysql InnoDB 事务隔离级别的支持程度")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/mysql/image-20200813211042362.png",alt:"image-20200813211042362"}})]),t._v(" "),_("h2",{attrs:{id:"表锁"}},[t._v("表锁")]),t._v(" "),_("p",[t._v("Lock share in mode")]),t._v(" "),_("h2",{attrs:{id:"排它锁"}},[t._v("排它锁")]),t._v(" "),_("p",[t._v("排他锁又称为写锁， 简称X锁")]),t._v(" "),_("p",[t._v("排它锁不能与其他锁并存， 如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的锁（共享锁、排他锁），只有该获取了排他锁的事务是可以对数据进行读取和修改的")]),t._v(" "),_("h3",{attrs:{id:"加锁方式："}},[t._v("加锁方式：")]),t._v(" "),_("ul",[_("li",[t._v("自动： delete/update/insert 默认加上X锁")]),t._v(" "),_("li",[t._v("手动： select * from student where id = 1 for update;")]),t._v(" "),_("li",[t._v("释放锁： 事务结束")])]),t._v(" "),_("h2",{attrs:{id:"意向锁"}},[t._v("意向锁")]),t._v(" "),_("p",[t._v("存储引擎自己维护的， 在加锁之前，先加一个意向锁，提高了效率")]),t._v(" "),_("h2",{attrs:{id:"锁的作用"}},[t._v("锁的作用")]),t._v(" "),_("p",[t._v("数据安全")]),t._v(" "),_("h2",{attrs:{id:"锁锁住的是什么？"}},[t._v("锁锁住的是什么？")]),t._v(" "),_("p",[t._v("锁锁住的是索引")]),t._v(" "),_("h3",{attrs:{id:"锁种类"}},[t._v("锁种类")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("Record Lock(精准命中的锁)")]),t._v(" "),_("blockquote",[_("p",[t._v("= 条件的时候")])])]),t._v(" "),_("li",[_("p",[t._v("Gap Lock  间隙锁")]),t._v(" "),_("blockquote",[_("p",[t._v("使用 > 或者 <  条件的时候， 是间隙锁")])])]),t._v(" "),_("li",[_("p",[t._v("临界锁")])])])])},[],!1,null,null,null);v.default=a.exports}}]);