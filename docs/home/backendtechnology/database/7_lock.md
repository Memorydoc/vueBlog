---
title: Mysql 事务与锁机制
---
# Mysql 事务与锁机制

## 下面的脏读、不可重复读、幻读都是 模拟在A、B事务中进行的

## 脏读

A 事务 读取某一值的数据， B事务将该值修改了， A中会读取到

![image-20200813210713283](/img/mysql/image-20200813210713283.png)

## 不可重复读

A 事务中 读取某一值的数据，B事务中将该值修改了， 并且 执行了commit ， 那么A中会读取到 (针对于 update  和  delete 语句)

![image-20200813210704429](/img/mysql/image-20200813210704429.png)

## 幻读

A事务中 查询某一条件中的所有数据，第一次查询出来 2条， B事务中在该命中条件下， 又插入了一条数据，那么A再次查询， 会查出来

3条数据，出现幻读（针对于insert语句）



![image-20200813210649975](/img/mysql/image-20200813210649975.png)



## 事务隔离级别总结

![image-20200813210738819](/img/mysql/image-20200813210738819.png)



> mysql 默认的事务隔离界别是 Repeatable Read 可重复读， 可以解决 上面 三大问题（InnoDB中可以解决）



## Mysql InnoDB 事务隔离级别的支持程度

![image-20200813211042362](/img/mysql/image-20200813211042362.png)

## 表锁

Lock share in mode

## 排它锁

排他锁又称为写锁， 简称X锁

排它锁不能与其他锁并存， 如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的锁（共享锁、排他锁），只有该获取了排他锁的事务是可以对数据进行读取和修改的

### 加锁方式： 

* 自动： delete/update/insert 默认加上X锁
* 手动： select * from student where id = 1 for update;
* 释放锁： 事务结束

## 意向锁



存储引擎自己维护的， 在加锁之前，先加一个意向锁，提高了效率



## 锁的作用

数据安全

## 锁锁住的是什么？

锁锁住的是索引

### 锁种类

* Record Lock(精准命中的锁)

  > = 条件的时候

* Gap Lock  间隙锁

  > 使用 > 或者 <  条件的时候， 是间隙锁

* 临界锁

