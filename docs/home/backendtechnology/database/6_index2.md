---
title: Mysql数据库索引原理（二）
---
## 索引

* 数据库索引，是数据库管理系统（DBMS）中的数据结构，以协助快速查询，更新数据库表中数据
* 索引类型分为三种： 普通索引（Normal）、唯一索引（Unique）、全文索引（Fulltext）
* 唯一索引值不能相同
* 主键索引又叫做特殊的唯一索引， 主键索引有一个特点： 值不能为空





## 索引的推引

###  二叉树

![image-20200802133117788](/img/mysql/image-20200802133117788.png)

> 数据的映射是按照顺序排序的， 但是特殊情况下，会出现复杂度log(N)



![image-20200802133237801](/img/mysql/image-20200802133237801.png)



### 平衡二叉树

![image-20200802133313595](/img/mysql/image-20200802133313595.png)

> 当左右子树深度差绝对值超过1之后，会出现左右旋转 如下：

1. 左旋

![image-20200802133411988](/img/mysql/image-20200802133411988.png)

2. 右旋

   ![image-20200802133513755](/img/mysql/image-20200802133513755.png)

AVL树的数据存储方式

![image-20200802133547154](/img/mysql/image-20200802133547154.png)

   **存在的问题:**  每个节点只会存在一个数据，这样树的深度会很大，会造成大量的IO操作， 每次查询Page的大小为16K，如果只放一个数据在节点上，会大大浪费

这16k的查询空间， 猜想是否可以将多个数据节点（数据、数据地址、左右子节点的指针） 存放在一个磁盘块，而每个磁盘块的大小为16k，事实证明。16k可以存放很多很多数据



### 多路平衡二叉树（B Tree）



![image-20200802134016408](/img/mysql/image-20200802134016408.png)

> 节点存储索引值，也存储 子节点的地址，但是有个问题， 如果值都存储的话，势必会导致树的深度变大，因为个磁盘块是16K， 如果存放的数据的话，那么会导致纵向变大



### B+Tree 加强版多路平衡查找树

![image-20200802162328560](/img/mysql/image-20200802162328560.png)

#### 优点

* B Tree 能解决的问题， B+Tree 都能解决
* 扫库、扫表能力更强
* 磁盘读写能力更强
* 排序、范围查找能力更强
* 效率更加稳定

### 哈希索引（只有Memory存储引擎才能使用）

![image-20200802162548129](/img/mysql/image-20200802162548129.png)

> 确定是不能进行对比大小， 因为hash是无序的，还会导致hash冲突问题

## 不同存储引擎

### MySAM 主键索引

![image-20200802162714092](/img/mysql/image-20200802162714092.png)

> 主键索引存储主键值、行数据地址

### MySAM 辅助索引（二级索引）



![image-20200802163023389](/img/mysql/image-20200802163023389.png![image-20200802163104338](/img/mysql/image-20200802163104338.png)

> 叶子节点存储行地址信息

### InnoDB 主键索引

![image-20200802163158051](/img/mysql/image-20200802163158051.png)

> 叶子节点存储主键值 和 行数据

### InnoDB 辅助索引（二级索引）

![image-20200802163250536](/img/mysql/image-20200802163250536.png)

> 叶子节点存储索引值 和主键值， 如果没有索引没有覆盖的话，那么会发生回表，数据会到主键索引中 根据id 再查询需要的字段

### 因为疑问？ 如果没有主键呢？

* 如果定义了主索引，那么主键索引就是聚集索引
* 如果你没有主键索引，但是你有一个不包含空值的唯一索引，那么就将这个唯一索引，当做聚集索引
* 如果既没有主键主键索引，也没有不包含空值的唯一索引，那么InnoDB中会为每一个生成一个RowId 当做聚集索引





## 索引创建和使用原则

### 散列度小的列，不要建立索引

比如在性别上， 除了男 就是女 ，那么在建立索引的时候， 还不如直接差全表快



### 最左匹配原则

### 覆盖索引

### 在什么字段上创建索引？

* where 、join 、order by
* 索引个数不要过度
* 散列度低的字段不要创建索引
* 随机无序或者频繁更新的值，不适合建立索引（用递增的ID作为主键索引，而不要用这种无序的UUID）
* 创建复合索引时避免冗余索引

### 什么时候索引失效

* 索引列上使用函数、表达式、运算符
* 出现隐式转换
* like 条件字符前面带% （最左前缀） （不一定）ICP
* 负向查询<> != not in 
